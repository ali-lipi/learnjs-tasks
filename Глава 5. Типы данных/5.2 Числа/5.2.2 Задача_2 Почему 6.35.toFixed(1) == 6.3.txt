ѕочему 6.35.toFixed(1) == 6.3?

важность: 4
ћетоды Math.round и toFixed, согласно документации, округл€ют до ближайшего целого числа: 0..4 округл€етс€ в меньшую сторону, тогда как 5..9 в большую сторону.

Ќапример:

alert( 1.35.toFixed(1) ); // 1.4
Ќо почему в примере ниже 6.35 округл€етс€ до 6.3?

alert( 6.35.toFixed(1) ); // 6.3
 ак правильно округлить 6.35?

----------------------------------------------------------------

–ешение: 
можно ли alert( (3.65.toFixed(2)).toFixed(1) ) ??
или alert( ((6.35 * 100) / 10).toFixed(1) );

*осталс€ вопрос по заданию, ответ посмотрела в учебнике*


==================================

ѕримечание (из учебника):
¬о внутреннем двоичном представлении 6.35 €вл€етс€ бесконечной двоичной дробью. ’ранитс€ она с потерей точностиЕ

ƒавайте посмотрим:

alert( 6.35.toFixed(20) ); // 6.34999999999999964473
ѕотер€ точности может как увеличивать, так и уменьшать число. ¬ данном случае число становитс€ чуть меньше, поэтому оно округл€етс€ в меньшую сторону.

ј дл€ числа 1.35?

alert( 1.35.toFixed(20) ); // 1.35000000000000008882
“ут потер€ точности приводит к увеличению числа, поэтому округление произойдЄт в большую сторону.

 аким образом можно исправить ошибку в округлении числа 6.35?

ћы должны приблизить его к целому числу, перед округлением:

alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
ќбратите внимание, что дл€ числа 63.5 не происходит потери точности. ƒело в том, что дес€тична€ часть 0.5 на самом деле 1/2. ƒробные числа, делЄнные на степень 2, точно представлены в двоичной системе, теперь мы можем округлить число:

alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4